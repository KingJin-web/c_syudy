## 线性表的定义

线性表 ： 零个或多个数据元素的集合
线性表元素的个数 n (n>=0) 定义为线性表的长度，当n=0是称之为**空表**

``` c++
ADT 线性表 (List)
Data
Operation  
    void initList(*L);	//创建并初始化一个空线性表，如果成功返回true，修改表传指针   
    bool listEmpty(L);	//判断一个线性表是否为空，不修改表传值   
    void clearList(*L);	//清空一个线性表，成功返回true   
    bool getElem(L,i,*e);	//从某个位置取出元素并赋值给e(i的范围是[1,L.length])，修改e的值所以传递一个指针，成功返回true  
    int locateElem(L,e);	//查找线性表中是否有e，如果有返回它的位置(从1开始)，否则返回0表示失败  
    bool listInsert(*L,i,e);	//插入一个元素e在第i个元素之前(i的取值范围是[1,L.length+1]) ，成功返回true   
    bool listDelete(*L,i,*e);	//删除在第i个位置上的元素(i的取值范围是[1,L.length]),删除的元素赋给e，成功返回true  
    int listLength(L);	//返回线性表的元素个数  
endADT
```



![avatar](..\img\1G0424H3-1.gif)


**使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。**
## 顺序存储结构和链式存储结构

![avatar](..\img\1G0425554-2.gif)
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;&emsp;&emsp;&emsp;图三
        
图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：
如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；
如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；

也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。

## 前驱和后继
数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据中的一个元素。

另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：
某一元素的左侧相邻元素称为“**直接前驱**”，位于此元素左侧的所有元素都统称为“**前驱元素**”；
某一元素的右侧相邻元素称为“**直接后继**”，位于此元素右侧的所有元素都统称为“**后继元素**”；

### 顺序存储结构
**定义** 线性表的顺序存储结构 指的是用一段地址连续的存储单元依次存储线性表的数据元素

线性表的顺序存储结构 代码
```c++
typedef int status; //定义函数返回的状态，OK & ERR
typedef int datatype; //定义线性表中每个结点的数据类型，这里暂定为int

typedef struct {
    datatype data[MAXSIZE]; //存储着线性表中的每个结点
    int length; //线性表当前的长度
} SequenceList;
```
- 储存空间的起始位置：数组date 他的存储位置就是 存储空间的存储位置
- 线性表最大存储容量：数组长度 MAXSIZE
- 线性表当前长度：length

### 顺序存储结构的插入与删除

#### 获得元素
实现GetElem 操作 将线性表第 i 个元素返回











grant all privileges on *.* to 'root'@'%' identified by 'aaaaa' with grant option;
flush privileges;














```c++
#include <stdio.h>
#include <stdlib.h>

#define OK 1
#define ERR 2
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20 //定义线性表的最大长度

typedef int status; //定义函数返回的状态，OK & ERR
typedef char datatype; //定义线性表中每个结点的数据类型，这里暂定为字符型

typedef struct {
    datatype data[MAXSIZE]; //存储着线性表中的每个结点
    int length; //线性表当前的长度
} SequenceList;

/* 函数原型，线性表的基本操作 */
SequenceList *createSequenceList(void);
status isEmpty(SequenceList *L);
void clear(SequenceList *L);
int getLength(SequenceList *L);
int locateNode(SequenceList *L,datatype node_to_locate);
datatype getNode(SequenceList *L, int index);
status insert(SequenceList *L, int index, datatype node_to_insert);
status delete(SequenceList *L, int index);
void showList(SequenceList *L);

int main(){
    /* 测试 */
    SequenceList *root; //指向线性表
    root=createSequenceList(); //创建一个线性表
    printf("Length = %d\n",getLength(root)); //打印线性表的当前长度
    printf("isEmpty = %d\n",isEmpty(root)); //打印线性表是否为空
    insert(root,0,'A'); //分别插入4个结点
    insert(root,0,'B');
    insert(root,1,'C');
    insert(root,1,'D');
    printf("Length = %d\n",getLength(root));
    printf("isEmpty = %d\n",isEmpty(root));
    showList(root); //打印线性表
    putchar('\n');
    delete(root,1); //删除index=1（数组下标为1）的结点
    showList(root);
    putchar('\n');
    printf("Locate = %d\n",locateNode(root,'A')); //打印查找到的结点的位置
    printf("getNode = %c\n",getNode(root,1)); //打印下标是1的结点的值
    clear(root); //清空线性表
    printf("isEmpty = %d",isEmpty(root));

    return 0;
}

SequenceList *createSequenceList(void){
    SequenceList *tmp;
    tmp=malloc(sizeof(SequenceList));//void*类型指针能自动转为其他类型的指针
    tmp->length=0; //初始化线性表长度
    return tmp;
}
status isEmpty(SequenceList *L){
    if (L->length==0)
        return TRUE;
    else
        return FALSE;
}
void clear(SequenceList *L){
    L->length=0;
}
int getLength(SequenceList *L){
    return L->length;
}
int locateNode(SequenceList *L, datatype node_to_locate){
    //返回找到的结点的index
    //node_to_locate应当是能唯一标识一个结点的数据，否则只返回匹配的第一个结点
    int i;
    for (i=0; i<L->length; i++){
        if (L->data[i]==node_to_locate)
            return i;
    }
    return -1; //未找到任何匹配
}
datatype getNode(SequenceList *L, int index){
    //index表示线性表中第N个结点，头结点的index是0
    if (L->length==0 || index<0 || index>L->length-1) return (datatype)ERR;
    return L->data[index];
}
status insert(SequenceList *L, int index, datatype node_to_insert){
    //node_to_insert表示想要插入的结点
    //当列表为空时，只有index=0才能插入
    int k;
    if (L->length == MAXSIZE) return ERR; //线性表已满
    if (index<0 || index>L->length) return ERR; //index不在有效范围
    if (index<L->length){
        //插入的位置不是最后一个结点的下一个结点
        for (k=L->length-1; k>=index; k--){
            L->data[k+1]=L->data[k]; //将要插入结点后面的所有结点都往后移
        }
    }
    L->data[index]=node_to_insert; //将新结点插入
    L->length++;
    return OK;
}
status delete(SequenceList *L, int index){
    int k;
    if (L->length == 0) return ERR; //线性表为空
    if (index<0 || index>L->length-1) return ERR; //index不在有效范围
    if (index<L->length-1){
        //删除的位置不是最后一个结点
        for (k=index; k<L->length-1; k++){
                L->data[k]=L->data[k+1]; //将删除位置后面的结点都往前移
        }
    }
    L->length--;
    return OK;
}
void showList(SequenceList *L){
    int i;
    for (i=0; i<L->length; i++){
        printf("%c\t",L->data[i]);
    }
}

/*
    顺序存储结构的线性表的优缺点：
    优点：
        1.不必为每个结点之间的逻辑关系增加额外的存储空间
        2.可以快速地读和写表中任意一个结点
    缺点：
        1.插入和删除需要移动大量结点
        2.线性表动态变化较大，难以确定所需的存储空间
        3.数组预设过长会造成空间浪费（存储碎片）
*/
/* 环境: Code::Blocks with GCC 5.1 */
```
